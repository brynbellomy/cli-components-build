require('../build/index.d.ts');
var fs = require('fs');
var path = require('path');
var $c = require('chalk');
var _ = require('lodash');
/**
    Returns the last-modified timestamp for the given file.
 */
function mtime(filepath) {
    if (fs.existsSync(filepath)) {
        var stat = fs.statSync(filepath);
        return stat.mtime.getTime();
    }
    return null;
}
exports.mtime = mtime;
/**
    Applies some simple, default ANSI formatting to the output of a call to
    `exec` based on the success or failure indicated by its return code.
 */
function prettyExecResult(result) {
    return '' + ((result.code === 0) ? $c.green('success')
        : $c.red("failed (code: " + result.code.toString() + ") output = " + result.output + ")"));
}
exports.prettyExecResult = prettyExecResult;
/**
    Parses the `tsconfig.json` at the specified path, assigns the keys/values in `assign` to the unserialized config
    object, and returns the result.
 */
var tsconfig = _.memoize(function (assign, filepath) {
    if (assign === void 0) { assign = {}; }
    if (filepath === void 0) { filepath = path.join(process.cwd(), 'tsconfig.json'); }
    var json = fs.readFileSync(filepath, 'utf8');
    var obj = JSON.parse(json);
    return _.assign(obj, assign);
});
exports.tsconfig = tsconfig;
/**
    Groups the given files by the given extensions.  Any files with other extensions are added to the `rest` array
    on the return value.
 */
function groupFiletypes(files, extensions) {
    var grouped = _.groupBy(files, function (file) {
        var ext = path.extname(file);
        return _.contains(extensions, ext) ? ext : '__rest';
    });
    var rest = grouped['__rest'];
    delete grouped['__rest'];
    return { grouped: grouped, rest: rest };
}
exports.groupFiletypes = groupFiletypes;
/**
    Returns `false` for ".min.js" files.  Returns `true` if `file` has the extension ".js" but not the extension ".min.js".
 */
function isUnminifiedJS(file) {
    return _.endsWith(file.toLowerCase(), '.js') && !_.endsWith(file.toLowerCase(), '.min.js');
}
exports.isUnminifiedJS = isUnminifiedJS;
/**
    Makes a halfhearted attempt to pretty print Typescript compile error objects generated by Browserify's `tsify` plugin.
 */
function prettyTSifyCompileError(err) {
    var y = $c.yellow, r = $c.red, g = $c.green, w = $c.white;
    err.message = err.message.replace(/^(.*)(?=Error)/, '');
    var quotedExprs = err.message.match(/'([^']*)'/g);
    if (!!quotedExprs) {
        quotedExprs = quotedExprs.map(function (expr) { return expr.replace(/\'/g, "").trim(); });
    }
    for (var _i = 0; _i < quotedExprs.length; _i++) {
        var expr = quotedExprs[_i];
        err.message = err.message.replace("'" + expr + "'", '' + w("'") + r(expr) + w("'"));
    }
    return [
        r('*** ERR '),
        y($c.underline(err.fileName) + ' ('),
        g('' + err.line),
        y(','),
        g('' + err.column),
        y(') '),
        err.message
    ].join('');
}
exports.prettyTSifyCompileError = prettyTSifyCompileError;
/**
    Colorizes and formats a simple "header" kind of thing.  You can surround text in asterisks to apply a highlight.  For example: "Installing *someprogram* version *1.0*"
 */
function header(text) {
    var matches = text.match(/\*[^\*]+\*/g);
    matches.forEach(function (match) {
        var extracted = match.replace(/(^\*)|(\*$)/g, '');
        text = text.replace(match, $c.white.bold(extracted));
    });
    var stars = $c.yellow('***');
    return [stars, text, stars].join(' ');
}
exports.header = header;
//# sourceMappingURL=index.js.map