import '../build/index.d.ts'

import * as asdf from 'cli-components-build'

import * as fs from 'fs'
import * as path from 'path'
import * as $c from 'chalk'
import * as _ from 'lodash'

export {
    mtime,
    header,
    tsconfig,
    groupFiletypes,
    isUnminifiedJS,
    prettyExecResult,
    prettyTSifyCompileError,
}

export interface ExecOutputReturnValue {
    code: number;
    output: string;
}

export interface TSConfigDictionary {
    [name: string]: any;
}

export interface GroupFiletypesResult {
    grouped: {
        [name: string]: string[];
    };
    rest: string[];
}


/**
    Returns the last-modified timestamp for the given file.
 */
function mtime (filepath: string): number {
    if (fs.existsSync(filepath)) {
        const stat = fs.statSync(filepath)
        return stat.mtime.getTime()
    }
    return null
}

/**
    Applies some simple, default ANSI formatting to the output of a call to
    `exec` based on the success or failure indicated by its return code.
 */
function prettyExecResult (result: ExecOutputReturnValue): string {
    return '' + ((result.code === 0)    ? $c.green('success')
                                        : $c.red(`failed (code: ${result.code.toString()}) output = ${result.output})`))
}

/**
    Parses the `tsconfig.json` at the specified path, assigns the keys/values in `assign` to the unserialized config
    object, and returns the result.
 */
var tsconfig = _.memoize(
    function (assign: {} = {}, filepath:string = path.join(process.cwd(), 'tsconfig.json')) {
        const json = fs.readFileSync(filepath, 'utf8')
        const obj  = JSON.parse(json)
        return <TSConfigDictionary>_.assign(obj, assign)
    }
)


/**
    Groups the given files by the given extensions.  Any files with other extensions are added to the `rest` array
    on the return value.
 */
function groupFiletypes (files: string[], extensions: string[]): GroupFiletypesResult
{
    const grouped = _.groupBy(files, (file) => {
        const ext = path.extname(file)
        return _.contains(extensions, ext) ? ext : '__rest'
    })
    const rest = grouped['__rest']
    delete grouped['__rest']
    return { grouped, rest }
}

/**
    Returns `false` for ".min.js" files.  Returns `true` if `file` has the extension ".js" but not the extension ".min.js".
 */
function isUnminifiedJS (file: string) {
    return _.endsWith(file.toLowerCase(), '.js') && !_.endsWith(file.toLowerCase(), '.min.js')
}

/**
    Error object returned by the `tsify` (Typescript compiler) plugin for Browserify.
 */
export interface TSifyCompileError {
    /** For example, 'src/user/index.ts(39,33): Error TS2304: Cannot find name \'PopupController\'.' */
    message: string;
    fileName: string;
    line: number;
    column: number;
    /** For example, 'TypeScript error'. */
    name: string;
}

/**
    Makes a halfhearted attempt to pretty print Typescript compile error objects generated by Browserify's `tsify` plugin.
 */
function prettyTSifyCompileError (err: TSifyCompileError) {
    const y = $c.yellow
      , r = $c.red
      , g = $c.green
      , w = $c.white

    err.message = err.message.replace(/^(.*)(?=Error)/, '')

    let quotedExprs = err.message.match(/'([^']*)'/g)
    if (!!quotedExprs) {
        quotedExprs = quotedExprs.map(function (expr) { return expr.replace(/\'/g, "").trim() })
    }

    for (const expr of quotedExprs) {
        err.message = err.message.replace( `'${expr}'`,
                                           '' + w(`'`) + r(expr) + w(`'`))
    }

    return [
        r('*** ERR '),
        y($c.underline(err.fileName) + ' ('),
            g('' + err.line),
        y(','),
            g('' + err.column),
        y(') '),
            err.message
    ].join('')
}

/**
    Colorizes and formats a simple "header" kind of thing.  You can surround text in asterisks to apply a highlight.  For example: "Installing *someprogram* version *1.0*"
 */
function header (text) {
    const matches = text.match(/\*[^\*]+\*/g)
    matches.forEach(function (match) {
        const extracted = match.replace(/(^\*)|(\*$)/g, '')
        text = text.replace(match, $c.white.bold(extracted))
    })
    const stars = $c.yellow('***')
    return [stars, text, stars].join(' ')
}




